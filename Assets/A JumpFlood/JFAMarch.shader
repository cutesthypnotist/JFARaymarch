// This shader raymarches a volume generated by JFA

Shader "Pema99/MercMarch"
{
    Properties
    {
        _MainTex("Buffer", 2D) = "white"{}
        _Iterations("Iterations", Range(1, 256)) = 50
        _MaxDist("Max distance", Range(0, 4000)) = 100
        _Cutoff("Cutoff", Range(0, 0.1)) = 0.01
        _Epsilon("Epsilon", Range(0.000001, 0.1)) = 0.01
    }
    SubShader
    {
        Tags { "Queue"="Transparent+500" "DisableBatching" = "True" }
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite On

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #include "JFACommon.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
                float3 ro_w : TEXCOORD1;
                float3 hitPos_w : TEXCOORD2;
            };

            sampler2D _MainTex;
            float _Iterations;
            float _MaxDist;
            float _Cutoff;
            float _Epsilon;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                o.ro_w = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));
                o.hitPos_w = v.vertex;
                return o;
            }

            float s_union( float d1, float d2, float k )
            {
                float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
                return lerp( d2, d1, h ) - k*h*(1.0-h);
            }

            // Perform trilinear interpolation
            float trilerp (float3 p, float v[8])
            {
                float3 d = frac(p);

                float c00 = lerp(v[0], v[0+4], d.x);
                float c01 = lerp(v[1], v[1+4], d.x);
                float c10 = lerp(v[2], v[2+4], d.x);
                float c11 = lerp(v[3], v[3+4], d.x);

                float c0 = lerp(c00, c10, d.y);
                float c1 = lerp(c01, c11, d.y);

                float c = lerp(c0, c1, d.z);

                return c;
            }

            float map(float3 p)
            {
                // Scale space from [-0.5; 0.5] to [0; volSize]
                float3 pp = saturate(p + 0.5);
                float3 pv = pp * volSize;

                // Get weights for trilinear interpolation, and perform it to get distance
                float v[8];
                for (uint i = 0; i < 8; i++)
                {
                    uint x = (i & 4) >> 2;
                    uint y = (i & 2) >> 1;
                    uint z = (i & 1);

                    float2 tc = VolToTex(pv + int3(x, y, z)) / float(texSize);
                    float dist = tex2Dlod(_MainTex, float4(tc, 0, 0));
                    v[i] = dist;
                }
                float dist = trilerp(pv, v);

                // Union with a moving sphere for demonstration
                dist = s_union((length(p + float3(-0.2, sin(_Time.y)*0.5, 0))-0.2), dist, 0.1);

                // Box clamp
                float3 q = abs(p) - (0.5-(1.0/volSize));
                dist = max(dist, length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)),0.0));

                return dist;
            }

            float3 normal(float3 p)
            {
                const float2 h = float2(_Epsilon,0);
                float3 n = (float3(map(p+h.xyy) - map(p-h.xyy),
                                   map(p+h.yxy) - map(p-h.yxy),
                                   map(p+h.yyx) - map(p-h.yyx)));

                return normalize(n);
            }

            float3 march(float3 ro, float3 rd)
            {
                float c = 1e5;
                float t = 0.0;
                
                for (int i = 0; i < _Iterations; i++) {
                    float3 p = ro + rd * t;
                    float closest = map(p);
                    c = min(c, closest);
                    t += closest;
                    if(t > _MaxDist || closest < _Cutoff) break;
                }
                
                return float3(t, i, c);
            }

            float4 frag (v2f i) : SV_Target
            {
                float3 ro = i.ro_w;
                float3 rd = normalize(i.hitPos_w - i.ro_w);

                float3 res = march(ro, rd);
                float dist = res.x;
                float ao = res.y / _Iterations;
                float closest = res.z;
                float3 norm = normal(ro + dist * rd) * 0.5 + 0.5;

                if (dist > _MaxDist)
                    return 0;
                else
                    return float4(norm, 1.0);
            }
            ENDCG
        }
    }
}
