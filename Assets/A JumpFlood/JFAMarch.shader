// This shader raymarches a volume generated by JFA

Shader "Pema99/MercMarch"
{
    Properties
    {
        _MainTex("Buffer", 2D) = "white"{}
        _Iterations("Iterations", Range(1, 256)) = 50
        _MaxDist("Max distance", Range(0, 4000)) = 100
        _Cutoff("Cutoff", Range(0, 0.1)) = 0.01
        _Epsilon("Epsilon", Range(0.000001, 0.1)) = 0.01
    }
    SubShader
    {
        Tags { "Queue"="Transparent+500" "DisableBatching" = "True" }
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite On

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #include "JFACommon.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
                float3 ro_w : TEXCOORD1;
                float3 hitPos_w : TEXCOORD2;
            };

            sampler2D _MainTex;
            float _Iterations;
            float _MaxDist;
            float _Cutoff;
            float _Epsilon;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                o.ro_w = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));
                o.hitPos_w = v.vertex;
                return o;
            }

            float s_union( float d1, float d2, float k )
            {
                float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
                return lerp( d2, d1, h ) - k*h*(1.0-h);
            }

            float map(float3 p)
            {
                // Scale space from [-0.5; 0.5] to [0; volSize]
                float3 pp = p + 0.5;
                float3 pv = pp * volSize;
                
                // Some kind of filtering, not really needed
                /*float3 sum = 0;
                for (int i = -1; i <= 1; i++)
                {
                    for (int j = -1; j <= 1; j++)
                    {
                        for (int k = -1; k <= 1; k++)
                        {
                            float2 tc = VolToTex(pv + int3(i, j, k)) / float(texSize);
                            float3 val = tex2Dlod(_MainTex, float4(tc, 0, 0));
                            sum += val * (1.0/27.0);
                        }
                    }
                }*/

                // Lookup seed, calculate distance
                float2 tc = VolToTex(pv) / float(texSize);
                float3 val = tex2Dlod(_MainTex, float4(tc, 0, 0));
                float dist = distance(val, pp);

                // Union with a moving sphere for demonstration
                dist = s_union((length(p + float3(-0.2, sin(_Time.y)*0.5, 0))-0.2), dist, 0.1);

                return dist;
            }

            float3 normal(float3 p)
            {
                const float2 h = float2(_Epsilon,0);
                float3 n = (float3(map(p+h.xyy) - map(p-h.xyy),
                                   map(p+h.yxy) - map(p-h.yxy),
                                   map(p+h.yyx) - map(p-h.yyx)));

                return normalize(n);
            }

            float3 march(float3 ro, float3 rd)
            {
                float c = 1e5;
                float t = 0.0;
                
                for (int i = 0; i < _Iterations; i++) {
                    float3 p = ro + rd * t;
                    float closest = map(p);
                    c = min(c, closest);
                    t += closest * (i / _Iterations); // evil hack
                    if(t > _MaxDist || closest < _Cutoff) break;
                }
                
                return float3(t, i, c);
            }

            float4 frag (v2f i) : SV_Target
            {
                float3 ro = i.ro_w;
                float3 rd = normalize(i.hitPos_w - i.ro_w);

                float3 res = march(ro, rd);
                float dist = res.x;
                float ao = res.y / _Iterations;
                float closest = res.z;
                float3 norm = normal(ro + dist * rd) * 0.5 + 0.5;

                if (dist > _MaxDist)
                    return 0;
                else
                    return float4(norm, 1.0);
            }
            ENDCG
        }
    }
}
